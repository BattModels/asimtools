Running an existing script
==========================

This section will guide you through running an already existing script whether
it be one of the scripts provided in the main repository, from the script
repository or a custom script you have written yourself.

To run a simulation, all you need to do is run either of the following
commands:

.. code-block:: console

    asim-execute sim_input.yaml -c calc_input.yaml -e env_input.yaml

or

.. code-block:: console

    asim-run sim_input.yaml -c calc_input.yaml

In either case, providing ``calc_input.yaml`` or ``env_input.yaml`` is optional. If
not provided, the globally configured files will be used. See BBBB. For most
cases, you will only ever use ``asim-execute``. The differences between
``asim-execute`` and ``asim-run`` are explained in BBBB.

sim_input.yaml
^^^^^^^^^^^^^^
The minimal requirement to run a script is to provide a ``sim_input.yaml`` file.
An example of a ``sim_input.yaml`` is shown below:

.. code-block:: yaml

    script: singlepoint 
    env_id: inline
    overwrite: false
    submit: true
    precommands:
        - export MY_ENV_VAR=3
    args:
        arg1: value_1
        arg2: value_2
        ... 

The parameters are:

- **script**: (str) name of core script or /path/to/my/script.py 
- **env_id**: (str, optional) Environment/context in which to run script
  configured in env_input.yaml, defaults to running in the current console
- **overwrite**: (bool, optional) (bool) whether or not to overwrite work
  directories if they exist, defaults to false 
- **submit**: (bool, optional) whether or not to run the script or instead just
  write the files to run the script without running the script, defaults to true 
- **precommands**: (list, optional) a list of commands to run in the console
  before running the script, defaults to empty list
- **postcommands**: (list, optional) a list of commands to run in the console
  after running the script, defaults to empty list
- **args**: (dict) The arguments of the function being called in the script as
  key-value pairs. These are specific to the script being run.

env_input.yaml
^^^^^^^^^^^^^^
Additionally, one can provide an ``env_input.yaml`` file that details the kind of
environments in which scripts can be run. This file can be provided with the
asim-execute command using the ``-e`` flag or set globally. An example of an
env_input.yaml file is given below

.. code-block:: yaml

    # template
    env_id:
      mode:
        use_slurm: true
        interactive: false
        run_prefix: ...
        run_postfix: ...
      slurm:
        flags: [flag1, flag2, ...]
        precommands: [precommand1, precommand2, ...]
        postcommands: [postcommand1, postcommand2, ...]
    
    # Concrete examples below
    inline: # Run the script directly in the commandline
      mode:
        use_slurm: false
        interactive: true

    batch_job: # Submit a batch job using slurm with 2 tasks
      mode:
        use_slurm: true
        interactive: false
      slurm: 
        flags:
            - -n 2
        precommands:
            - source ~/.bashrc
            - conda activate asimtools
        postcommands:
            - conda deactivate asimtools

    interactive_job: # Submit an interactive job using slurm
      mode:
        use_slurm: true
        interactive: true
      slurm:
        flags:
          - -n 2
          - --gres:gpu=2
        precommands:
          - module load lammps

The highest level key is the ``env_id`` which is specified in the
``sim_input.yaml``. An ``env_input.yaml`` can have any number of ``env_id`` s. That
way you can specify one global file if you use the same environments
repeatedly. In particular, you can configure a global config file by setting
the environment variable.

.. code-block:: console

    export ASIMTOOLS_ENV_INPUT=/path/to/my/global/env_input.yaml

The parameters, required, shown in the template section are  are described below

- **env_id**: (str) unique key for identifying the environment, ``env_id`` in
  ``sim_input.yaml`` must match one of the ``env_id`` s defined in the provided
  ``env_input.yaml``
- **env_id.mode.use_slurm**: (bool) whether or not to request a slurm
  allocation to run the script
- **env_id.mode.interactive**: (bool) whether or not to request a slurm
  allocation to run the script directly in the terminal (using ``salloc``) or
  to submita batch job (using ``sbatch``)
- **env_id.mode.run_prefix**: (str) string to append before running the script
  e.g. if ``run_prefix=mpirun`` the script will be inkoked with the equivalent
  of ``mpirun python my_script.py``. ``run_prefix`` in ``env_input.yaml`` is
  always prepended before the one provided by ``calc_input.yaml``.
- **env_id.mode.run_postfix**: (str) string to append after running the script
  e.g. if ``run_postfix=' &> out.txt'`` the script will be inkoked with the
  equivalent of ``python my_script.py &> out.txt``. ``run_postfix`` in
  ``env_input.yaml`` is always appended after the one provided by
  ``calc_input.yaml``.
- **env_id.slurm.flags**: (list, optional) The slurm flags for the allocation
  as a list of flags e.g. ``[-n 4, -N 1]``
- **env_id.slurm.precommands**: (list, optional) Commands to be run/added to
  the job script before running the script. A common use cas is loading a
  module or activating an environment
- **env_id.slurm.postcommands**: (list, optional) Commands to be run/added to
  the job script after running the script.

calc_input.yaml
^^^^^^^^^^^^^^^
Lastly the ``calc_input.yaml`` is used to configure an ASE calculator. As
above, a global configuration file can be set using

.. code-block:: console

    export ASIMTOOLS_CALC_INPUT=/path/to/my/global/calc_input.yaml

or provided to asim-execute at run time. Note that if you launch a chained
workflow with ``asim-run`` instead of ``asim-execute``, scripts farther down
the chain will use the global ``calc_input.yaml``


.. code-block:: yaml

  # Template
  calc_id:
    name: ...
    module: ...
    precommands: [precommand1, ...]
    postcommands: [postcommand1, ...]
    run_prefix: ...
    run_postfix: ...
    args:
      arg1: value_1
      ...

  # Concrete examples
  lj: 
    name: LennardJones
    module: ase.calculators.lj
    args:
      sigma: 3.54
      epsilon: 0.00802236

  # GPAW needs a run_prefix to work in parallel using mpirun
  gpaw:
    name: GPAW
    module: gpaw.calculator
    run_prefix: mpirun 
    args:
      kpts: [2,2,2]
      h: 0.1
      xc: PBE
      txt: gpaw_output.txt


- **calc_id**: (str) unique key for identifying the calculator, ``calc_id`` in
  ``sim_input.yaml`` must match one of the ``calc_id`` s defined in the
  provided ``calc_input.yaml``
- **calc_id.name**: (str) Either the name of the class or the reference to one
  of the provided BBBB external calculators. 
- **calc_id.module**: (str) The module from which the calculator class is
  imported. e.g. if ``name=LennardJones`` and ``module=ase.calculators.lj``,
  then the calculator object is imported as ``from ase.calculators.lj import
  LennardJones``. This works if the calculator is available in ASE or follows
  ASE format for initialization such as GPAW. Any other ASE calculator will
  need to have the instantiation defined in :ref:calculators.py
- **calc_id.mode.run_prefix**: (str) string to append before running the script
  e.g. if ``run_prefix=mpirun`` the script will be inkoked with the equivalent
  of ``mpirun python my_script.py``. ``run_prefix`` in ``env_input.yaml`` is
  always prepended before the one provided by ``calc_input.yaml``.
- **calc_id.mode.run_postfix**: (str) string to append after running the script
  e.g. if ``run_postfix=' &> out.txt'`` the script will be inkoked with the
  equivalent of ``python my_script.py &> out.txt``. ``run_postfix`` in
  ``env_input.yaml`` is always appended after the one provided by
  ``calc_input.yaml``.
- **calc_id.precommands**: (list, optional) Commands to be run/added to the job
  script before running the script. A common use cas is loading a module or
  activating an environment
- **calc_id.postcommands**: (list, optional) Commands to be run/added to the
  job script after running the script.
- **calc_id.args**: (dict) key-value pairs to be passed as arguments for the
  initialization of the calculator class. e.g. if the class is LennardJones,
  the arguments are passed as ``calc = LennardJones(**{'sigma':3.2,
  'epsilon':3})``

